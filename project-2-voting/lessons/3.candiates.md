Q1:explain what data structure is used to store candiates?

## Q1: Data Structure for Storing Candidates

Candidates are stored using the **`CandidateAccount`** struct in Rust:

```rust
#[account]
#[derive(InitSpace)]
pub struct CandidateAccount {
    #[max_len(32)]
    pub candidate_name: String,      // Name of the candidate/option
    
    pub candidate_votes: u64,        // Number of votes received
}
```

### Breakdown of Each Field

| Field | Type | Purpose | Example |
|-------|------|---------|---------|
| `candidate_name` | String (max 32 chars) | The name of the voting option | "smooth", "crunchy", "Chocolate" |
| `candidate_votes` | u64 (unsigned 64-bit integer) | Counter tracking total votes | `0`, `42`, `1000` |

### Key Characteristics

1. **`#[account]`** - Marks this as a Solana on-chain account that persists data
2. **`#[derive(InitSpace)]`** - Automatically calculates required storage space
3. **`#[max_len(32)]`** - Limits candidate name to 32 characters to control storage costs
4. **`u64`** - Vote count can go up to 18,446,744,073,709,551,615 (practically unlimited)

### How Candidates Are Stored

#### Storage Location
- **On-chain**: Each candidate gets its own Solana account
- **Address**: Calculated using a Program Derived Address (PDA)
- **PDA Seeds**: `[poll_id, candidate_name]`
  - Example: For poll_id=1 and candidate="smooth", the PDA is derived from `[1, "smooth"]`

#### Uniqueness
- Each candidate in a poll has a **unique account** based on:
  - The poll it belongs to (`poll_id`)
  - Its name (`candidate_name`)
- This means you can't have duplicate candidate names in the same poll

### Initialization Process

When a candidate is created via `initialize_candidate`:

```rust
#[account(
    init,                              // Create new account
    payer = signer,                    // Signer pays for account creation
    space = 8 + CandidateAccount::INIT_SPACE,  // Allocate space
    seeds = [poll_id.to_le_bytes().as_ref(), candidate.as_ref()],  // PDA seeds
    bump                               // Store the bump seed
)]
pub candidate_account: Account<'info, CandidateAccount>
```

**What happens:**
1. A new `CandidateAccount` is created on-chain
2. `candidate_name` is set to the provided name
3. `candidate_votes` starts at `0`
4. The poll's `poll_option_index` is incremented (tracks candidate count)

### Relationship to Poll

- **One-to-Many**: One `PollAccount` can have many `CandidateAccount` entries
- **Linking**: Candidates are linked to polls via the `poll_id` in their PDA seeds
- **Independence**: Each candidate account is separate and independent

### Example Usage

From the test file:
```typescript
// Create candidate "smooth" for poll #1
await program.methods.initializeCandidate(
  new anchor.BN(1),    // poll_id
  "smooth"             // candidate_name
)

// Creates CandidateAccount with:
// - candidate_name: "smooth"
// - candidate_votes: 0
// - PDA address: [poll_id=1, "smooth"]
```

### How Votes Are Recorded

When someone votes:
```rust
candidate_account.candidate_votes += 1;  // Increment vote count
```

- The vote count is **directly stored** in the candidate's account
- Each vote increments the counter by 1
- The count persists on-chain and can be queried anytime

### Storage Efficiency

**Why separate accounts?**
- ✅ Each candidate can be queried independently
- ✅ Vote counts are isolated (one candidate's votes don't affect others)
- ✅ Easy to add/remove candidates without affecting others
- ✅ Parallel processing possible (multiple candidates updated simultaneously)

**Space Calculation:**
- `8 bytes`: Account discriminator (Anchor requirement)
- `4 bytes`: String length prefix for `candidate_name`
- `32 bytes`: Maximum for `candidate_name` (with `#[max_len(32)]`)
- `8 bytes`: `candidate_votes` (u64)
- **Total**: ~52 bytes per candidate account

### Key Takeaways

1. **Simple Structure**: Only 2 fields - name and vote count
2. **On-Chain Storage**: Each candidate is a separate Solana account
3. **PDA-Based**: Address derived from poll_id + candidate name
4. **Vote Tracking**: Direct counter that increments with each vote
5. **Scalable**: Can handle many candidates per poll efficiently



Q2: how does it store multiple candidates?
different seeds -> different account address. 
seeds :[poll_id, candidate_name]